---
title: "Advanced Annotations"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Advanced Annotations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(EGM)
```

The advanced annotation guide is for the `annotation_table()` function, but is concerned with more complex features and uses. 
Some of these approaches are *opionated*. 
Feel free to raise [issues](https://github.com/shah-in-boots/EGM/issues) as appropriate.

1. Writing multichannel annotations
1. Plotting multichannel annotations

# Examples of Annotations

```{r, eval=FALSE}
# Read in an ECG that has been annotated
rec <- "muse-sinus"
rec_dir <- system.file('extdata', package = 'EGM') 
ann <- read_annotation(rec, rec_dir, "ecgpuwave")
```

```{r, eval=FALSE}
# Let x = 10-second signal dataset
# We will apply this across the dataset
# This is an oversimplified approach.
find_peaks <- function(x,
                       threshold = 
                         mean(x, na.rm = TRUE) + 2 * sd(x, na.rm = TRUE)
                       ) {
  
  # Ensure signal is "positive" for peak finding algorithm
  x <- abs(x)
  
  # Find the peaks
  peaks <- which(diff(sign(diff(x))) == -2) + 1
  
  # Filter the peaks
  peaks <- peaks[x[peaks] > threshold]
  
  # Return
  peaks
}

# Create a signal dataset
dat <- extract_signal(ecg)

# Apply the function across all of the data channels
# Then stack into a data column to obtain hte labels
pks <- 
  lapply(dat[-1], find_peaks) |>
  utils::stack()

# Format to match the internals of the `ggm` object
# Create an empty column to "nab" the voltage values from the raw data
names(pks) <- c("sample", "label")
pks$mV <- NA

# For loops.. my favorite, however generally slow in R
for (i in 1:nrow(pks)) {
  pks$mV[i] <- dat[[pks$label[i]]][pks$sample[i]]
}

# Now add to the original figure
fig +
  geom_point(inherit.aes = FALSE, data = pks, aes(x = sample, y = mV))

```
